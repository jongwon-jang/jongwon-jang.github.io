---
title: "Swift Journey No.2 - More Data Types"
date: 2021-05-28 22:00:00 -0500
categories: other
---
# Complex Data Types

## Arrays
Arrays are collections of values that are stored as a single value

```swift
let iphone = "iPhone 12 Pro Max"
let macbook = "Macbook Pro 16"
let ipad = "iPad Pro 12.9"

let apple = [iphone, macbook, ipad]
```

You can read values from an array by writing a number inside a bracket
```swift
apple[1]
```
Swift crashes if you read an item that doesn't exist. (for example, `apple[5]` will produce an error)

## Sets
Sets are collections of values just like arrays, but they have 2 differences
1. Items __aren't stored in orders__ (it is stored randomly)
2. All items must be __unique__

```swift
let colors = Set(["red", "green", "blue", "green", "blue"])
```
`colors` set will only include red, green, and blue once.

## Tuples
Tuples allow you to store several values together in a single value.
Sounds like arrays, but the differences are:
1. You can't add or remove items from a tuple (__size fixed__)
2. You __can't change the type of items__ in a tuple
3. You can access items using __numerical positions__ or by __naming__ them (but cannot read numbers or names that don't exist)

```swift
var name = (first: "Jongwon", last: "Jang")
```
You can access items like:
```swift
name.0
name.first
```

## Arrays vs Sets vs Tuples
If you need a __specific__, __fixed__ collection of related values, use a *tuple*
```swift
let address = (streetNo: 777, street: "Lucky Ave", city: "Toronto")
```

If you need a collection of values that should be __unique__ or to be able to check if there is a __specific item in there__, use a *set*
```swift
let books = Set(["Nike Bio", "Jobs Bio", "Marvel Comic", "Software Testing", "Marvel Comic"])
```
Marvel Comic will only be stored once

If you need a collection that can contain __duplicates__, or the __order matters__, use an *array*
```swift
let languages = ["Python", "Swift", "Java", "Java" ]
```

## Dictionaries
`Dictionaries` are collections of values like `arrays`, but rather than storing things with an integer position, you can access them using anything you want
```swift
let imdb = [
    "Star Wars": 9.5,
    "Harry Potter": 7.7
]
```
You seperate the value you want to store from the identifier(__keys__) using a colon
`keys` can be used to read data back out of the dictionary:
```swift
imdb["Star Wars"]
```
When using type annotations, dictionaries are written in brackets with a colon between the identifier and value types, like:
```swift
[String: String]
[Double: String]
```

## Dictionary Default Values
If you try to read a value from a dictionary using a key that doesn't exist, Swift will send you back `nil`
We can provide a default value to use if we request a missing key
```swift
let devj = [
    "first": "Jongwon"
    "last": "Jang"
```
If we try to read `devj`'s `middle` value:
```swift
devj["middle"]
```
we would get back `nil`. However, we can fix this by giving a default value of our own like:
```swift
devj["middle", default: "unknown"]
```

## Creating Empty Collections
`Arrays`, `Sets`, and `Dictionaries` are called __collections__
You can create an empty collection by writing its type followed by opening and closing parentheses
```swift
var apple = [String: String]()    // Creating empty dictionary
apple["phone"] = "iPhone"    // add entities

var score = [Int]()    // Creating empty array

var numbers = Set<Int>()    // Creating empty set
```
Creating empty set is done differently. Swift has special syntax for `dictionaries` and `arrays`

## Enumerations
Enumerations - usually called `enums` - are a way of defining groups of related values.
```swift
let result = "failure"
let result2 = "fail"
```
`result` and `result2` mean different things.
To prevent using different naming for the same meaning, we can define an `Result` type enum that can be either `success` and `failure`
```swift
enum Result {
    case success
    case failure
}
```
When we use it, we must choose either one of those two values:
```swift
let result3 = Result.failure
```
This can help prevent using different strings each time

## Enum Associated Values
`Enums` can store associated values to each case
```swift
enum State {
    case running(destination: String)
    case sleeping(duration: Int)
    case eating(food: String)
}
```
Now we can be more precise:
```swift
let eating = State.eating(food: "Pizza")
```

## Enum Raw Values
Sometimes we want to assign values to enums. 
To create Level enum that stores `Int` values:
```swift
enum Level: Int {
    case beginner
    case intermediate
    case professional
}
```
Swift will automatically assign each of those numbers starting from 0.
You can use that number to create an instance of the appropriate enum case
```swift
let devj = Level(rawValue: 2)    // This will assign professional to devj
```
